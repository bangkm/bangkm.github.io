<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bangkm</title>
  
  <subtitle>Daily Develop&#39;s</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bangkm.github.io/"/>
  <updated>2019-10-22T10:17:58.303Z</updated>
  <id>https://bangkm.github.io/</id>
  
  <author>
    <name>Bangkm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS Programming - Univ.Stanford Lecture04</title>
    <link href="https://bangkm.github.io/2019/10/22/Univ-Stanford-Lecture-4/"/>
    <id>https://bangkm.github.io/2019/10/22/Univ-Stanford-Lecture-4/</id>
    <published>2019-10-22T10:16:20.000Z</published>
    <updated>2019-10-22T10:17:58.303Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Core-Keyword"><a href="#Core-Keyword" class="headerlink" title="Core Keyword"></a>Core Keyword</h3><ul><li>Mutating</li><li>Protocol</li><li>Closer</li><li>String</li></ul><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p><strong>스위프트의 자료 구조를 형성하는 네번째 기둥</strong>. API와 Caller 사이에서 서로 원하는 바를 충족시킬 수 있도록 도와준다. API가 Caller에게 원하는 메소드나 프로퍼티를 Caller가 구현하도록 하며, Caller는 자신이 원하는 class/ struct/ enum을 전달 할 수 있다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> : <span class="title">class</span>, <span class="title">InheritedProtocol1</span>, <span class="title">InheritedProtocol2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> someProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">aMethod</span><span class="params">(arg1: Double, anotherArgument: String)</span></span> -&gt; <span class="type">SomeType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeIt</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(arg: <span class="type">Type</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SomeProtocol을 상속받는 경우 InheritedProtocol1, InheritedProtocol2도 구현해 줘야 한다. </p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>문자열은 유니코드들로 만들어 지지만 Character라는 개념이 있으며, 통상 Character는 사람이 인식하는 문자다. <strong>문자열은 또한 Character의 콜렉션 이다.</strong> 즉, index(of:)와 같은 메소드들은 Collecttion의 일부</p><p>Collection은 <strong>Sequence</strong>이기 때문에 <strong>for 루프를 통해서 각 Character 값에 접근</strong>할 수 있습니다.</p><p>문자열은 구조체로 만들어져있기 때문에 value 타입이다. 통상 문자열은 상수로 선언을 하지만 경우에 따라서는 변수로 선언할 수 있다. 이와 같은 경우 <strong>구조체이므로 내부의 값을 바꾸고자 할 때는 mutating이라는 예약어를 사용</strong>해야 하며, <strong>insert(contentsOf: at:)이 그중 하나</strong>의 예입니다.</p><h3 id="Learning-Today"><a href="#Learning-Today" class="headerlink" title="Learning Today"></a>Learning Today</h3><ul><li>Change to Struct from Class</li><li>Apply Protocol in Concentration Game</li></ul><h6 id="Card-swift"><a href="#Card-swift" class="headerlink" title="Card.swift"></a>Card.swift</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> hashValue: <span class="type">Int</span> &#123; <span class="keyword">return</span> identifier &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Card, rhs: Card)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.identifier == rhs.identifier</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> isFaceUp = <span class="literal">false</span> <span class="comment">// 앞/뒤 구분, 뒷면에서 시작할거기 때문에 false</span></span><br><span class="line">    <span class="keyword">var</span> isMatched = <span class="literal">false</span> <span class="comment">// 매치 구분, 처음 시작시 모두 false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> identifier: <span class="type">Int</span> <span class="comment">// 카드 고유 id</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> identifierFactory = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getUniqueIdentifier</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        identifierFactory += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> identifierFactory</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.identifier = <span class="type">Card</span>.getUniqueIdentifier()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Apply Property</li></ul><h6 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> flipCountLabel: <span class="type">UILabel!</span> &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    updateFlipCountLabel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">private</span> <span class="keyword">var</span> cardButtons: [<span class="type">UIButton</span>]!</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK:- Properties</span></span><br><span class="line"><span class="comment">// game이 private가 필한 이유 -&gt; numberOfPairOfCard(카드 쌍)의 갯수에 따라 UI가 달라지기 때문에</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> game = <span class="type">Concentration</span>(numberOfPairOfCards: numberOfPairOfCards)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 카드의 수를 궁금해할 수는 있으나 설정은 안된다</span></span><br><span class="line"><span class="comment">// But, 이미 읽기 전용 메소드가 있기 때문데 private(set) 직접 설정 X</span></span><br><span class="line"><span class="keyword">var</span> numberOfPairOfCards: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (cardButtons.<span class="built_in">count</span> + <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// 읽기 전용은 get 생략가능</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 획수를 궁금해할 수는 있다. 하지만 값 설정은 X</span></span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> flipCount = <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">didSet</span> &#123;</span><br><span class="line">    updateFlipCountLabel()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updateFlipCountLabel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> attributes: [<span class="type">NSAttributedString</span>.<span class="type">Key</span>: <span class="type">Any</span>] = [</span><br><span class="line">    .strokeWidth : <span class="number">5.0</span>,</span><br><span class="line">    .strokeColor : <span class="type">UIColor</span>.orange</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> attributedString = <span class="type">NSAttributedString</span>(string: <span class="string">"Count: \(flipCount)"</span>, attributes: attributes)</span><br><span class="line">  flipCountLabel.attributedText = attributedString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Apply Closer in Concentration Game</li></ul><h6 id="Concentration-swift"><a href="#Concentration-swift" class="headerlink" title="Concentration.swift"></a>Concentration.swift</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Concentration</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> indexOfOneAndOnlyFaceUpCard: <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cards.<span class="built_in">indices</span>.<span class="built_in">filter</span> &#123; cards[$<span class="number">0</span>].isFaceUp &#125;.oneAndOnly</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> cards.<span class="built_in">indices</span> &#123;</span><br><span class="line">                cards[index].isFaceUp = (index == newValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oneAndOnly: <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span> == <span class="number">1</span> ? first : <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/bangkm/ios-develops-in-univ.stanford/tree/eb507201d5eabd845544ad0b5c61ef28404b4530" target="_blank" rel="noopener">Source</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Core-Keyword&quot;&gt;&lt;a href=&quot;#Core-Keyword&quot; class=&quot;headerlink&quot; title=&quot;Core Keyword&quot;&gt;&lt;/a&gt;Core Keyword&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Mutating&lt;/li&gt;
&lt;li&gt;Protoc
      
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://bangkm.github.io/categories/iOS-Programming/"/>
    
    
      <category term="Univ.Stanford iOS Programming" scheme="https://bangkm.github.io/tags/Univ-Stanford-iOS-Programming/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#2178) - Search Maze(BFS/DFS Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/16/BaekJoon(2178)/"/>
    <id>https://bangkm.github.io/2019/10/16/BaekJoon(2178)/</id>
    <published>2019-10-16T10:56:28.000Z</published>
    <updated>2019-10-16T11:00:48.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×M크기의 배열로 표현되는 미로가 있다.</p><table><thead><tr><th>1</th><th><strong>0</strong></th><th><strong>1</strong></th><th><strong>1</strong></th><th><strong>1</strong></th><th><strong>1</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td></tr><tr><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td></tr><tr><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>1</strong></td><td><strong>0</strong></td><td><strong>1</strong></td><td><strong>1</strong></td></tr></tbody></table><p>미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.</p><p>위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 <strong>붙어서</strong> 입력으로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.</p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">101111</span></span><br><span class="line"><span class="number">101010</span></span><br><span class="line"><span class="number">101011</span></span><br><span class="line"><span class="number">111011</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">110110</span></span><br><span class="line"><span class="number">110110</span></span><br><span class="line"><span class="number">111111</span></span><br><span class="line"><span class="number">111101</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">25</span></span><br><span class="line"><span class="number">1011101110111011101110111</span></span><br><span class="line"><span class="number">1110111011101110111011101</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">38</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br><span class="line"><span class="number">1011111</span></span><br><span class="line"><span class="number">1110001</span></span><br><span class="line"><span class="number">1000001</span></span><br><span class="line"><span class="number">1000001</span></span><br><span class="line"><span class="number">1000001</span></span><br><span class="line"><span class="number">1000001</span></span><br><span class="line"><span class="number">1111111</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>(0, 0)에서 부터 시작하여 상하좌우 칸들이 이동가능한 칸인지 확인하고 이미 지나온 칸이라도 이동 가능한(1) 칸이라면 값을 갱신한다. 단, ( 지나온 칸 + 1) &lt; 최소 칸 수 일 경우. 대기열에 있는 칸들의 상하좌우 경로를 탐색하며 (N-1, M-1)까지 이동하는데 최소의 칸 수를 계산하는 것이다. 탐색해야 하는 대기열이 비워지면 마지막 지점에 오는데 거쳐온 최소의 칸수가 기록된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMazeWithBFS</span><span class="params">( current, destination, matrix )</span>:</span></span><br><span class="line">    destination_x, destination_y = destination</span><br><span class="line">    dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">    dy = [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    queue = [current]</span><br><span class="line">    footPrint = [current]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        x, y = queue.pop(<span class="number">0</span>)</span><br><span class="line">        xy = matrix[x][y]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            x_dx = x + dx[i]</span><br><span class="line">            y_dy = y + dy[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x_dx &lt; <span class="number">0</span> <span class="keyword">or</span> y_dy &lt; <span class="number">0</span> <span class="keyword">or</span> x_dx &gt;= N <span class="keyword">or</span> y_dy &gt;= M:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            isPass = matrix[x_dx][y_dy]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isPass == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> isPass == <span class="number">1</span> <span class="keyword">or</span> xy + <span class="number">1</span> &lt; isPass:</span><br><span class="line">                matrix[x_dx][y_dy] = xy + <span class="number">1</span></span><br><span class="line">                queue.append( (x_dx, y_dy) )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> matrix[destination_x][destination_y]</span><br><span class="line"></span><br><span class="line">N, M = map(int, input().split())</span><br><span class="line">matrix = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">    matrix.append( list(map(int, input())) )</span><br><span class="line"></span><br><span class="line">currentPoint = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(searchMazeWithBFS(currentPoint, (N<span class="number">-1</span>, M<span class="number">-1</span>), matrix))</span><br></pre></td></tr></table></figure><p><a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/BFS_DFS/maze" target="_blank" rel="noopener">Source</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;N×M크기의 배열로 표현되는 미로가 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="BFS/DFS Algorithm" scheme="https://bangkm.github.io/tags/BFS-DFS-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Programmers(#42883) - Make Large Number</title>
    <link href="https://bangkm.github.io/2019/10/15/Programmers(42883)/"/>
    <id>https://bangkm.github.io/2019/10/15/Programmers(42883)/</id>
    <published>2019-10-15T09:36:50.000Z</published>
    <updated>2019-10-15T09:41:17.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.</p><p>예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.</p><p>문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</p><h3 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h3><ul><li>number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.</li><li>k는 1 이상 <code>number의 자릿수</code> 미만인 자연수입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><table><thead><tr><th align="left">number</th><th align="center">k</th><th align="center">return</th></tr></thead><tbody><tr><td align="left">“1924”</td><td align="center">2</td><td align="center">“94”</td></tr><tr><td align="left">“1231234”</td><td align="center">3</td><td align="center">“3234”</td></tr><tr><td align="left">“4177252841”</td><td align="center">4</td><td align="center">“775841”</td></tr></tbody></table><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h6 id="큰-수-만들기"><a href="#큰-수-만들기" class="headerlink" title="큰 수 만들기"></a>큰 수 만들기</h6><ul><li>앞 자리에 큰 수가 오면 전체가 커진다<ul><li>큰 수를 우선으로 저장한다.</li></ul></li></ul><p>앞 자리에서부터 하나씩 골라서 리스트에 저장한다. 리스트 마지막 값이 현재 저장하려는 값보다 작은 경우 리스트에서 제거하고 현재 값을 저장한다. 단, 주어진 k번만 제거할 수 있다.</p><ol><li>맨 마지막 문자 비교 - 주어진 숫자를 큰 값 순으로 리스트에 저장하여 리스트에는 내림차순으로 정렬되어있다.</li><li>현재 저장하려는 값이 리스트에 저장되어 있는 마지막 원소 값 보다 큰 경우 리스트에서 마지막 원소를 제거한다. <code>pop()</code>. 또한, k값을 하나 감소 시킨다.</li><li>2번 과정의 반복으로 k값이 0이되면 제거할 수 있는 갯수를 모두 소모한 것이다. 그러므로 현재 <code>index</code> 값 이후의 <code>number</code> 값을 리스트에 저장한다.</li><li>저장된 리스트에서 전체 길이의 <code>-k</code> 만큼의 원소를 출력한다.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(number, k)</span>:</span></span><br><span class="line">    collected = []</span><br><span class="line">    <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(number):</span><br><span class="line">        <span class="keyword">while</span> len(collected) &gt; <span class="number">0</span> <span class="keyword">and</span> collected[<span class="number">-1</span>] &lt; num <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            collected.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            collected += list(number[i:])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        collected.append(num)</span><br><span class="line"></span><br><span class="line">    collected = collected[:-k] <span class="keyword">if</span> k &gt; <span class="number">0</span> <span class="keyword">else</span> collected</span><br><span class="line">    answer = <span class="string">''</span>.join(collected)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><a href="https://github.com/bangkm/study-algorithm/tree/master/programmers/greedy_algorithm/make%20lage%20number" target="_blank" rel="noopener">Source</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 숫자 1924에
      
    
    </summary>
    
    
      <category term="Programmers Algorithm" scheme="https://bangkm.github.io/categories/Programmers-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>iOS Programming - Univ.Stanford Lecture03</title>
    <link href="https://bangkm.github.io/2019/10/15/Univ-Stanford-Lecture-3/"/>
    <id>https://bangkm.github.io/2019/10/15/Univ-Stanford-Lecture-3/</id>
    <published>2019-10-15T08:00:53.000Z</published>
    <updated>2019-10-15T08:02:42.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Core-Keyword"><a href="#Core-Keyword" class="headerlink" title="Core Keyword"></a>Core Keyword</h3><ul><li>Tuple</li><li>Computed Property</li><li>Access Control</li><li>Extension</li><li>enum</li><li>Optional</li></ul><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p><code>for i in A</code>  A에 해당하는 값은 Int 타입(CountableRange Type). 부동소수를 사용은 <code>for i in stride(from:, through:, by:)</code> 라는 전역함수를 사용한다.</p><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>Tuple은 <strong>메소드나 변수가 없는 소형 구조체</strong>. 튜플은 각각의 값의 이름을 설정할 수 있다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTuple: (<span class="type">String</span>, <span class="type">Int</span>, <span class="type">Double</span>) = (<span class="string">"hello"</span>, <span class="number">5</span>, <span class="number">0.85</span>)</span><br><span class="line"><span class="keyword">let</span> (word, number, value) = myTuple</span><br><span class="line"><span class="built_in">print</span>(word) <span class="comment">// hello</span></span><br><span class="line"><span class="built_in">print</span>(number) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">print</span>(value) <span class="comment">// 0.85</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x:(w: <span class="type">String</span>, i: <span class="type">Int</span>, v: <span class="type">Double</span>) = (<span class="string">"Hello"</span>, <span class="number">5</span>, <span class="number">0.85</span>)</span><br><span class="line"><span class="built_in">print</span>(x.w) <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">print</span>(x.i) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">print</span>(x.v) <span class="comment">// 0.85</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (wrd, num, val) = x</span><br></pre></td></tr></table></figure><p>Swift의 함수는 하나의 값만 반환한다. 하지만 튜플을 사용하면 여러개의 값들을 반활할 수 있다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSize</span><span class="params">()</span></span> -&gt; (weight: <span class="type">Double</span>, height: <span class="type">Double</span>) &#123; <span class="keyword">return</span> (<span class="number">250</span>, <span class="number">80</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myTuple1 = getSize()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"weight is \(myTuple1.height)"</span>) <span class="comment">// 80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"height is \(getSize().height)"</span>) <span class="comment">// 80</span></span><br></pre></td></tr></table></figure><h5 id="Tuple-vs-Dictionary"><a href="#Tuple-vs-Dictionary" class="headerlink" title="Tuple vs. Dictionary"></a>Tuple vs. Dictionary</h5><ul><li>Tuple은 함수에서 여러개의 값을 반활할 수 있다.</li><li>Tuple은 이미 선언된 개수의 값만 넣을 수 있다.</li><li>Tuple은 다른 데이터 타입의 값을 포함할 수 있다.</li></ul><h3 id="Computed-Property"><a href="#Computed-Property" class="headerlink" title="Computed Property"></a>Computed Property</h3><p>메모리에 저장되지 않고 호출할 때마다 값을 가지고, 새로운 값이 설정 될때 마다 틀정 역할을 수행하는 프토퍼티</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo: <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 호출 시</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">    <span class="comment">// 새로운 값 설정 시</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><p>소규모 프로젝트는 접근제어에 대한 요구가 드물다. 하지만 프로젝트가 커짐에 따라 API를 사용하는 경우가 많아지고 미리 약속되어 있는 키워드를 사용함으로서 API에 접근한다.</p><ul><li>Internal (Default) : 앱, 프레임워크 내에서 접근 가능</li><li>Private: <strong>객체 내</strong>에서만 접근 가능</li><li>Private(set) :  호출은 할 수 있지만 <strong>값 설정은 하지 못한다.</strong></li><li>Fileprivate: <strong>Source File</strong> 내에서 접근 가능하도록 할 때 사용</li><li>public: 프레임워크 밖에서도 객체에 의해 사용 가능</li><li>open: 프레임워크 밖에서도 객체에 의해 사용 가능, 상속 받아 override도 사용 가능</li></ul><h3 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h3><p>현재 존재하는 데이터 구조를 <strong>확장</strong>할 수 있다. class/struct/enum등에 method, properties를 추가할 수 있다.</p><p>한가지 제한 사항은 <strong>저장할 수 있는 공간이 없다.</strong></p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>일종의 데이터 타입으로 <strong>제한적인 선택지를 제공</strong>하고 싶을 때 사용. 열거형의 개별 상태는 연동된 데이터를 가질 수 있다.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FastFoodMenuItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> hamburger(numberOfPatties: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> fries(size: <span class="type">FryOrderSize</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> drink(<span class="type">String</span>, ounces: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> cookie</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">FryOrderSize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> large</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> small</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> myHamburger = <span class="type">FastFoodMenuItem</span>.hamburger(numberOfPatties: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> yetAnotherItem = .cookie</span><br></pre></td></tr></table></figure><p>기존에 있던 연동 데이터의 이름을 바꿀 수 도 있고 이름이 없는 경우에는 새로운 이름을 할당할 수 있다. 메소드는 가능하지만, <strong>저장 프로퍼티는 불가능하다</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> menuItem &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> .hamburger(<span class="keyword">let</span> pattyCount): <span class="built_in">print</span>(<span class="string">"a burger with \(pattyCount) patties!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> .fries: <span class="built_in">print</span>(<span class="string">"fries"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> .drink(<span class="keyword">let</span> brand, <span class="keyword">let</span> ounces): <span class="built_in">print</span>(<span class="string">"a \(ounces)oz \(brand)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">print</span>(<span class="string">"other"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>일종의 enum.  어떠한 값이든 올수있는 제네릭이며, 값을 가지거나 가지지 않는 두가지 경우만 존재</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">        <span class="keyword">case</span> some(&lt;<span class="type">T</span>&gt;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Learning-Today"><a href="#Learning-Today" class="headerlink" title="Learning Today"></a>Learning Today</h3><ul><li>Apply Computed Properties in Concentration Game</li></ul><h6 id="Concentration-swift"><a href="#Concentration-swift" class="headerlink" title="Concentration.swift"></a>Concentration.swift</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> indexOfOneAndOnlyFaceUpCard: <span class="type">Int?</span> &#123;</span><br><span class="line">       <span class="keyword">get</span> &#123; <span class="comment">// indexOfOneAndOnlyFaceUpCard 호출 시</span></span><br><span class="line">           <span class="keyword">var</span> foundIndex: <span class="type">Int?</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">for</span> index <span class="keyword">in</span> cards.<span class="built_in">indices</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> cards[index].isFaceUp &#123;</span><br><span class="line">                   <span class="keyword">if</span> foundIndex == <span class="literal">nil</span> &#123;</span><br><span class="line">                       foundIndex = index</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> foundIndex</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">set</span> &#123; <span class="comment">// indexOfOneAndOnlyFaceUpCard 값 변경 시</span></span><br><span class="line">           <span class="keyword">for</span> index <span class="keyword">in</span> cards.<span class="built_in">indices</span> &#123;</span><br><span class="line">               cards[index].isFaceUp = (index == newValue)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>Apply Access Control in Concentration Game</li></ul><h6 id="ViewController-swift-Card-swift-Concentration-swift-Properties-amp-method"><a href="#ViewController-swift-Card-swift-Concentration-swift-Properties-amp-method" class="headerlink" title="ViewController.swift / Card.swift / Concentration.swift - Properties &amp; method"></a>ViewController.swift / Card.swift / Concentration.swift - Properties &amp; method</h6><ul><li>Apply Extension in Concentration Game</li></ul><h6 id="ViewController-swift"><a href="#ViewController-swift" class="headerlink" title="ViewController.swift"></a>ViewController.swift</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arc4Random: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="keyword">self</span>)))</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">self</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(<span class="built_in">abs</span>(<span class="keyword">self</span>))))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/bangkm/ios-develops-in-univ.stanford/tree/958d1b463798d7598909216ce6a68e644bede16c" target="_blank" rel="noopener">Source</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Core-Keyword&quot;&gt;&lt;a href=&quot;#Core-Keyword&quot; class=&quot;headerlink&quot; title=&quot;Core Keyword&quot;&gt;&lt;/a&gt;Core Keyword&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Tuple&lt;/li&gt;
&lt;li&gt;Computed 
      
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://bangkm.github.io/categories/iOS-Programming/"/>
    
    
      <category term="Univ.Stanford iOS Programming" scheme="https://bangkm.github.io/tags/Univ-Stanford-iOS-Programming/"/>
    
  </entry>
  
  <entry>
    <title>iOS Programming - Univ.Stanford Lecture02</title>
    <link href="https://bangkm.github.io/2019/10/15/Univ-Stanford-Lecture-2/"/>
    <id>https://bangkm.github.io/2019/10/15/Univ-Stanford-Lecture-2/</id>
    <published>2019-10-15T07:51:55.000Z</published>
    <updated>2019-10-15T08:00:11.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li><p><strong>M</strong> (Model) - 앱이 <strong>무엇</strong>인지에 대한 관심, UI와 독립</p></li><li><p><strong>V</strong> (View) - UIButton, UIViewController, UILabel와 같은 UI와 관련된 것, Controller의 통제를 받는다</p></li><li><p><strong>C</strong>(Controller) - <strong>어떻게</strong> 화면에 표시할 것인지</p></li></ul><h3 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h3><h4 id="Model과-Controller"><a href="#Model과-Controller" class="headerlink" title="Model과 Controller"></a>Model과 Controller</h4><p>Controller는 모델에 직접적으로 접근할 수 있지만, Model은 Controller에 Notification &amp; KVO 방식을 통해</p><p>모델의 변화를 알립니다.</p><h4 id="Model과-View"><a href="#Model과-View" class="headerlink" title="Model과 View"></a>Model과 View</h4><p>Model은 UI에 독립적이며 View와 소통할 수 없으며, View 또한 불가능합니다.</p><h4 id="View와-Controller"><a href="#View와-Controller" class="headerlink" title="View와 Controller"></a>View와 Controller</h4><p>Controller는 View에 대해 outlet을 이용해 View에게 직접적으로 접근할 수 있습니다. =</p><p>View는 Controller에게 구조적으로 미리 정해진 방식으로 Controller에게 행위에 대한 요청(delegate)과</p><p>데이터에 대한 요청(data source)을 할 수 있습니다. 뿐만 아니라, action(View) - target(controller)의 구조로</p><p>사용자의 행위에 따라 필요한 함수를 호출할 수도 있습니다.</p><p><img src="https://cphinf.pstatic.net/mooc/20180511_278/1526016689274NyXIr_PNG/mvc.png" alt></p><h3 id="Learning-Today"><a href="#Learning-Today" class="headerlink" title="Learning Today"></a>Learning Today</h3><ol><li>Make <strong>Concentration Model</strong></li><li>Make <strong>Card Structure</strong></li><li><strong>init Card</strong></li><li>Add <strong>Static</strong> Function &amp; Variable</li><li><strong>Flip Card</strong> Function</li></ol><p><a href="https://github.com/bangkm/ios-develops-in-univ.stanford/tree/ab97f391f0af99399e49e32c3a91ece5ccc8c411/Concentration%20Game" target="_blank" rel="noopener">Source</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MVC&quot;&gt;&lt;a href=&quot;#MVC&quot; class=&quot;headerlink&quot; title=&quot;MVC&quot;&gt;&lt;/a&gt;MVC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;M&lt;/strong&gt; (Model) - 앱이 &lt;strong&gt;무엇&lt;/strong&gt;인지에 대한
      
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://bangkm.github.io/categories/iOS-Programming/"/>
    
    
      <category term="Univ.Stanford iOS Programming" scheme="https://bangkm.github.io/tags/Univ-Stanford-iOS-Programming/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#1931) - Conference Room (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/09/BaekJoon(1931)/"/>
    <id>https://bangkm.github.io/2019/10/09/BaekJoon(1931)/</id>
    <published>2019-10-09T13:20:53.000Z</published>
    <updated>2019-10-13T13:47:28.855Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의들에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 최대수의 회의를 찾아라. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2^31-1보다 작거나 같은 자연수 또는 0이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 최대 사용할 수 있는 회의 수를 출력하여라.</p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">13</span></span><br><span class="line"><span class="number">12</span> <span class="number">14</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="힌트"><a href="#힌트" class="headerlink" title="힌트"></a>힌트</h3><p>(1,4), (5,7), (8,11), (12,14) 를 이용할 수 있다.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>회의가 끝나는 시간을 기준으로 정렬 후 다음 회의의 시작 시간이 전 회의 시간보다 크거나 같으면 해당 회의를 추가한다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>]) </span><br><span class="line"><span class="comment"># 회의 목록 리스트에서 회의가 끝나는 시간, 즉 x[1]을 시간대로 정렬 후 다시 회의 시작시간인 x[0]으로 정렬</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"></span><br><span class="line">conferences = sorted([list(map(int, input().split())) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)], key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>], x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">endTime = result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> conference <span class="keyword">in</span> conferences:</span><br><span class="line">    <span class="keyword">if</span> endTime &lt;= conference[<span class="number">0</span>]:</span><br><span class="line">        endTime = conference[<span class="number">1</span>]</span><br><span class="line">        result += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/conferenceroom" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/conferenceroom</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의들에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#10610) - 30 (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/08/BaekJoon(10610)/"/>
    <id>https://bangkm.github.io/2019/10/08/BaekJoon(10610)/</id>
    <published>2019-10-08T14:25:56.000Z</published>
    <updated>2019-10-08T14:46:03.168Z</updated>
    
    <content type="html"><![CDATA[<p>###문제</p><p>어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.</p><p>미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>N을 입력받는다. N는 최대 105개의 숫자로 구성되어 있으며, 0으로 시작하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>미르코가 만들고 싶어하는 수가 존재한다면 그 수를 출력하라. 그 수가 존재하지 않는다면, -1을 출력하라.</p><h3 id="예제-입력1"><a href="#예제-입력1" class="headerlink" title="예제 입력1"></a>예제 입력1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력1"><a href="#예제-출력1" class="headerlink" title="예제 출력1"></a>예제 출력1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력2"><a href="#예제-입력2" class="headerlink" title="예제 입력2"></a>예제 입력2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">102</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력2"><a href="#예제-출력2" class="headerlink" title="예제 출력2"></a>예제 출력2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">210</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력3"><a href="#예제-입력3" class="headerlink" title="예제 입력3"></a>예제 입력3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2931</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력3"><a href="#예제-출력3" class="headerlink" title="예제 출력3"></a>예제 출력3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li>30의 배수 조건<ul><li>한개 이상의 0을 가지고 있어야 한다.</li><li>각 자리수의 합이 3의 배수여야 한다.</li></ul></li></ul><p>임의 정수 N을 입력 받아 각 자리수를 잘라 0부터 9까지 숫자가 몇개로 조합됬는지 확인한다. N의 각 자리수를 비교하여 0이 없거나 각 자리수의 합이 3으로 나누었을 때 나머지가 0이 아니면 (N % 3 != 0)  <strong>-1</strong>을 출력한다. 이 두 조건을 모두 만족하면 30의 배수가 될 수 있는 수 임으로, 0-9까지 각 숫자의 개수를 가지고 있는 리스트를 역으로 반복하여 문자열에 합해준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">number = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">N = list(map(int, input()))</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(N)):</span><br><span class="line">    a = N[i]</span><br><span class="line">    number[a] += <span class="number">1</span></span><br><span class="line">    total += a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> N <span class="keyword">or</span> <span class="keyword">not</span>(total % <span class="number">3</span>  == <span class="number">0</span>):</span><br><span class="line">    print(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((len(number) - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> number[i] &gt; <span class="number">0</span>:</span><br><span class="line">            result += str(i)</span><br><span class="line">            number[i] -= <span class="number">1</span></span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/30" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/30</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###문제&lt;/p&gt;
&lt;p&gt;어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.&lt;/p&gt;
&lt;p&gt;미르코를 도
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#5585) - BFS/DFS (BFS/DFS Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/07/BaekJoon(1260)/"/>
    <id>https://bangkm.github.io/2019/10/07/BaekJoon(1260)/</id>
    <published>2019-10-07T09:40:30.000Z</published>
    <updated>2019-10-07T09:43:46.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.</p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">1</span> <span class="number">1000</span></span><br><span class="line"><span class="number">999</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">999</span></span><br><span class="line"><span class="number">1000</span> <span class="number">999</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>DFS(Depth First Search)와 BFS(Breadth First Search)의 기초 개념을 잡을 수 있는 문제다. DFS는 깊이 우선 탐색으로 가장 하위 노드까지 탐색 후 다시 올라와 방문하지 않은 노드를 탐색하는 방법이며, BFS는 넒이 우선 탐색으로 자식 노드를 모두 탐색 후 하위 노드로 내려가 탐색하는 방식을 얘기한다.</p><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F993501355C67E8C013E4BA" width="300" height="300"> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F997B6C3D5C67E90823D689" width="300" height="300"></p><p>​            DFS(Depth First Search)                                BFS(Breadth First Search)</p><p>[ 이미지 출처 ] <a href="https://this-programmer.com/entry/" target="_blank" rel="noopener">https://this-programmer.com/entry/</a></p><p>위 문제를 해결하기 위해 인접행렬(Adjacency Matrix)를 사용했다. 인접행렬이란 자료형의 일종으로 어느 노드끼리 연결되었는지를 나타내는 이차원 행렬을 의미한다.</p><p>연결되어 있지 않은 노드는 0, 연결된 노드끼리는 1의 값을 저장한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">          [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">          [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">          [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><ul><li><p>BFS</p><p>탐색을 시작할 노드를 Queue에 저장하고 방문한 노드이므로 footPrint에도 똑같이 저장한다. Queue가 비어있을때 까지 반복문을 통해 노드를 탐색한다. 시작 노드와 같은 수준에 있는 노드를 탐색하고 같은 수준의 모든 노드를 탐색 후 하위 노드로 내려가 탐색을 이어간다. </p></li><li><p>DFS</p><p>탐색을 시작할 노드를 방문한 노드를 저장하는  footPrint에 저장하고 인접행렬을 통해 현재 노드와 연결된 노드를 탐색한다. 연결된 노드가 아직 방문하지 않은 노드라면 재귀호출을 통해 연결된 노드를 추가하고 연결된 노드를 시작 노드로하여 탐색을 이어간다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">N, M, V = map(int, input().split())</span><br><span class="line">matrix = [[<span class="number">0</span>] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(M):</span><br><span class="line">    edge = list(map(int, input().split()))</span><br><span class="line">    matrix[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">    matrix[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">( currentNode, row, footPrints )</span>:</span></span><br><span class="line">    footPrints += [currentNode]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> search_node <span class="keyword">in</span> range(len(row[currentNode])):</span><br><span class="line">        <span class="keyword">if</span> row[currentNode][search_node] <span class="keyword">and</span> search_node <span class="keyword">not</span> <span class="keyword">in</span> footPrints:</span><br><span class="line">            footPrints = dfs(search_node, row, footPrints)</span><br><span class="line">    <span class="keyword">return</span> footPrints</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">( start )</span>:</span></span><br><span class="line">    queue = [start]</span><br><span class="line">    footPrints = [start]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        currentNode = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> search_node <span class="keyword">in</span> range(len(matrix[currentNode])):</span><br><span class="line">            <span class="keyword">if</span> matrix[currentNode][search_node] <span class="keyword">and</span> search_node <span class="keyword">not</span> <span class="keyword">in</span> footPrints:</span><br><span class="line">                footPrints += [search_node]</span><br><span class="line">                queue += [search_node]</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> footPrints</span><br><span class="line"></span><br><span class="line">print(*dfs(V, matrix, []))</span><br><span class="line">print(*bfs(V))</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/BFS_DFS/BFSDFS" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/BFS_DFS/BFSDFS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="BFS/DFS Algorithm" scheme="https://bangkm.github.io/tags/BFS-DFS-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#5585) - Change (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/06/BaekJoon(5585)/"/>
    <id>https://bangkm.github.io/2019/10/06/BaekJoon(5585)/</id>
    <published>2019-10-06T11:50:56.000Z</published>
    <updated>2019-10-06T11:54:46.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 준다. 타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.</p><p>예를 들어 입력된 예1의 경우에는 아래 그림에서 처럼 4개를 출력해야 한다.</p><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/5585/1.png"><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>제출할 출력 파일은 1행으로만 되어 있다. 잔돈에 포함된 매수를 출력하시오.</p><h3 id="예제-입력"><a href="#예제-입력" class="headerlink" title="예제 입력"></a>예제 입력</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">380</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력"><a href="#예제-출력" class="headerlink" title="예제 출력"></a>예제 출력</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>잡화점에서 보유하고 있는 잔돈 500, 100, 50, 10, 5, 1엔을 리스트에 저장한 후 타로가 카운터에 제출한 1000엔에서 물건 값을 뺀 후 가장 적은 수의 잔돈을 계산한다.</p><p><strong>백준 알고리즘 - #11047</strong> 문제와 유사한 문제로 동일하게 divmod(a, b) 함수를 사용하여 잔돈 갯수의 최소값을 구한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = divmod(x, y) <span class="comment"># x를 y로 나눈 후, 몫은 a, 나머지는 b 변수에 저장된다</span></span><br></pre></td></tr></table></figure><p>몫은 필요한 동전의 개수로 result 변수에 더해주고, 나머지는 필요한 동전만큼 빼고 현재 남은 금액을 나타냄으로 현재 남은 잔돈의 금액에 저장하며 잔돈이 0원이 될때까지 반복 후 총 잔돈의 갯수를 출력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">price = int(input())</span><br><span class="line">changes = [<span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">change = <span class="number">1000</span> - price</span><br><span class="line"></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> changes:</span><br><span class="line">    <span class="keyword">if</span> change &lt; i:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a, b = divmod(change, i)</span><br><span class="line">        result += a</span><br><span class="line">        change = b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> change == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/change" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/change</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#11399) - Coin (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/05/BaekJoon(11047)/"/>
    <id>https://bangkm.github.io/2019/10/05/BaekJoon(11047)/</id>
    <published>2019-10-04T15:21:15.000Z</published>
    <updated>2019-10-04T15:25:10.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.</p><p>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)</p><p>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.</p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">4200</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">500</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">5000</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">4790</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">500</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">5000</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>동전의 종류를 역순으로 현재 가지고 있는 금액과 비교한다. 동전의 종류가 현재 가지고 있는 금액보다 크면 continue, 작으면  divmod 함수를 사용하여 몫과 나머지를 구해준다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = divmod(x, y) <span class="comment"># x를 y로 나눈 후, 몫은 a, 나머지는 b 변수에 저장된다</span></span><br></pre></td></tr></table></figure><p>몫은 필요한 동전의 개수로 result 변수에 더해주고, 나머지는 필요한 동전만큼 빼고 현재 남은 금액을 나타냄으로 현재 가지고 있는 금액 변수인 haveCash에 저장하여 금액이 0원이 될때까지 반복 후 동전의 갯수를 출력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kindOfcoine = []</span><br><span class="line">nAndk = list(map(int, input().split()))</span><br><span class="line">haveCash = nAndk[<span class="number">1</span>]</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nAndk[<span class="number">0</span>]):</span><br><span class="line">    kindOfcoine.append(int(input()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(kindOfcoine):</span><br><span class="line">    <span class="keyword">if</span> haveCash &lt; i:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a, b = divmod(haveCash, i)</span><br><span class="line">        result += a</span><br><span class="line">        haveCash = b</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> haveCash == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/coin" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/coin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.&lt;/p&gt;
&lt;p&gt;동전을 적절히 사용해서 그 가치
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CodeUp(#2001) - MinumumPayment (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/04/MinumumPayment/"/>
    <id>https://bangkm.github.io/2019/10/04/MinumumPayment/</id>
    <published>2019-10-03T17:18:35.000Z</published>
    <updated>2019-10-03T17:25:12.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>파파 파스타 가게는 점심 추천 파스타와 생과일 쥬스 세트 메뉴가 인기가 좋다. 이 세트 메뉴를 주문하면 그 날의 3 종류의 파스타와 2 종류의 생과일 쥬스에서 하나씩 선택한다. <strong>파스타와 생과일 쥬스의 가격 합계에서 10%를 더한 금액이 대금된다.</strong> 어느 날의 파스타와 생과일 쥬스의 가격이 주어 졌을 때, 그 날 세트 메뉴의 대금의 최소값을 구하는 프로그램을 작성하라.</p><hr><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 5행으로 이루어지며, 한 줄에 하나씩 양의 정수가 적혀있다.</p><p>1행의 점수는 <strong>첫 번째 파스타</strong> 가격이다.</p><p>2행의 점수는 <strong>두 번째 파스타</strong> 가격이다.</p><p>3행의 점수는 <strong>세 번째 파스타</strong> 가격이다.</p><p>4행의 점수는 <strong>첫 번째 생과일 쥬스</strong> 가격이다.</p><p>5행의 점수는 <strong>두 번째 생과일 쥬스</strong> 가격이다.</p><p>(모든 파스타와 생과일 쥬스의 가격은 100원 이상 2000원 이하이다)</p><hr><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>그날 세트 메뉴의 <strong>최소 대금을 소수 첫째자리까지</strong> 출력하시오.</p><hr><h3 id="입력-예시"><a href="#입력-예시" class="headerlink" title="입력 예시"></a>입력 예시</h3><p>800</p><p>700</p><p>900</p><p>198</p><p>330</p><hr><h3 id="출력-예시"><a href="#출력-예시" class="headerlink" title="출력 예시"></a>출력 예시</h3><p>987.8</p><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>배열의 인덱스 0~2는 파스타의 가격, 3-4는 생과일 쥬스의 가격이다. 이중 for loop로 파스타에 해당되는 인덱스(0-2)와 생과일 쥬스에 해당되는 인덱스(3-4)의 가격을 더한 후 합이 제일 작은 금액을 구한다. 마지막으로 최소 금액의 10%를 더한 값을 출력한다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">800</span>, <span class="number">700</span>, <span class="number">900</span>, <span class="number">198</span>, <span class="number">330</span>]</span><br><span class="line">totalPrice = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> pasta <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> drink <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">5</span>):</span><br><span class="line">        sumPrice = prices[pasta] + prices[drink]</span><br><span class="line">        <span class="keyword">if</span> pasta == <span class="number">0</span> <span class="keyword">and</span> drink == <span class="number">3</span>:</span><br><span class="line">            totalPrice = sumPrice</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sumPrice &lt; totalPrice:</span><br><span class="line">            totalPrice = sumPrice</span><br><span class="line"></span><br><span class="line">print(totalPrice + (totalPrice * <span class="number">0.1</span>))</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/code-up/MinimunPayment" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/code-up/MinimunPayment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;파파 파스타 가게는 점심 추천 파스타와 생과일 쥬스 세트 메뉴가 인기가 좋다. 이 세트 메뉴를 주문하면 그 날의 3 종류의 파
      
    
    </summary>
    
    
      <category term="Code-Up Algorithm" scheme="https://bangkm.github.io/categories/Code-Up-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#11399) - ATM (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/04/BaekJoon(11399)/"/>
    <id>https://bangkm.github.io/2019/10/04/BaekJoon(11399)/</id>
    <published>2019-10-03T16:34:58.000Z</published>
    <updated>2019-10-03T17:17:12.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.</p><p>사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.</p><p>줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.</p><p>줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.</p><h3 id="예제-입력"><a href="#예제-입력" class="headerlink" title="예제 입력"></a>예제 입력</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력"><a href="#예제-출력" class="headerlink" title="예제 출력"></a>예제 출력</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>각 사람의 돈을 인출하는데 걸리는 시간이 가장 작은 순으로 줄을스면 인출하는데 걸리는 시간의 총합의 최솟값을 구할 수 있다. 즉, 오름 차순으로 정렬하여 각 사람당 인출하는데 걸리는 시간을 구하고 시간의 총합을 구하면 최솟값이 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">times = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">times.sort()</span><br><span class="line">sumList = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">    sumList += time</span><br><span class="line">    result.append(sumList)</span><br><span class="line"></span><br><span class="line">print(sum(result))</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/atm" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/atm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
</feed>
