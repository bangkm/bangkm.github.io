<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bangkm</title>
  
  <subtitle>Daily Develop&#39;s</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bangkm.github.io/"/>
  <updated>2019-10-08T14:30:12.176Z</updated>
  <id>https://bangkm.github.io/</id>
  
  <author>
    <name>Bangkm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tete</title>
    <link href="https://bangkm.github.io/2019/10/08/BaekJoon(10610)/"/>
    <id>https://bangkm.github.io/2019/10/08/BaekJoon(10610)/</id>
    <published>2019-10-08T14:25:56.000Z</published>
    <updated>2019-10-08T14:30:12.176Z</updated>
    
    <content type="html"><![CDATA[<p>###문제</p><p>어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.</p><p>미르코를 도와 그가 만들고 싶어하는 수를 계산하는 프로그램을 작성하라.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>N을 입력받는다. N는 최대 105개의 숫자로 구성되어 있으며, 0으로 시작하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>미르코가 만들고 싶어하는 수가 존재한다면 그 수를 출력하라. 그 수가 존재하지 않는다면, -1을 출력하라.</p><h3 id="예제-입력1"><a href="#예제-입력1" class="headerlink" title="예제 입력1"></a>예제 입력1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력1"><a href="#예제-출력1" class="headerlink" title="예제 출력1"></a>예제 출력1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력2"><a href="#예제-입력2" class="headerlink" title="예제 입력2"></a>예제 입력2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">102</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력2"><a href="#예제-출력2" class="headerlink" title="예제 출력2"></a>예제 출력2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">210</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력3"><a href="#예제-입력3" class="headerlink" title="예제 입력3"></a>예제 입력3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2931</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력3"><a href="#예제-출력3" class="headerlink" title="예제 출력3"></a>예제 출력3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ul><li>30의 배수 조건<ul><li>한개 이상의 0을 가지고 있어야 한다.</li><li>각 자리수의 합이 3의 배수여야 한다.</li></ul></li></ul><p>임의 정수 N을 입력 받아 각 자리수를 잘라 0부터 9까지 숫자가 몇개로 조합됬는지 확인한다. N의 각 자리수를 비교하여 0이 없거나 각 자리수의 합이 3으로 나누었을 때 나머지가 0이 아니면 (N % 3 != 0)  <strong>-1</strong>을 출력한다. 이 두 조건을 모두 만족하면 30의 배수가 될 수 있는 수 임으로, 0-9까지 각 숫자의 개수를 가지고 있는 리스트를 역으로 반복하여 문자열에 합해준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">number = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">N = list(map(int, input()))</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(N)):</span><br><span class="line">    a = N[i]</span><br><span class="line">    number[a] += <span class="number">1</span></span><br><span class="line">    total += a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> N <span class="keyword">or</span> <span class="keyword">not</span>(total % <span class="number">3</span>  == <span class="number">0</span>):</span><br><span class="line">    print(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((len(number) - <span class="number">1</span>), <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> number[i] &gt; <span class="number">0</span>:</span><br><span class="line">            result += str(i)</span><br><span class="line">            number[i] -= <span class="number">1</span></span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/30" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/30</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###문제&lt;/p&gt;
&lt;p&gt;어느 날, 미르코는 우연히 길거리에서 양수 N을 보았다. 미르코는 30이란 수를 존경하기 때문에, 그는 길거리에서 찾은 수에 포함된 숫자들을 섞어 30의 배수가 되는 가장 큰 수를 만들고 싶어한다.&lt;/p&gt;
&lt;p&gt;미르코를 도
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#5585) - BFS/DFS (BFS/DFS Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/07/BaekJoon(1260)/"/>
    <id>https://bangkm.github.io/2019/10/07/BaekJoon(1260)/</id>
    <published>2019-10-07T09:40:30.000Z</published>
    <updated>2019-10-07T09:43:46.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.</p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">1</span> <span class="number">1000</span></span><br><span class="line"><span class="number">999</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span> <span class="number">999</span></span><br><span class="line"><span class="number">1000</span> <span class="number">999</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>DFS(Depth First Search)와 BFS(Breadth First Search)의 기초 개념을 잡을 수 있는 문제다. DFS는 깊이 우선 탐색으로 가장 하위 노드까지 탐색 후 다시 올라와 방문하지 않은 노드를 탐색하는 방법이며, BFS는 넒이 우선 탐색으로 자식 노드를 모두 탐색 후 하위 노드로 내려가 탐색하는 방식을 얘기한다.</p><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F993501355C67E8C013E4BA" width="300" height="300"> <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F997B6C3D5C67E90823D689" width="300" height="300"></p><p>​            DFS(Depth First Search)                                BFS(Breadth First Search)</p><p>[ 이미지 출처 ] <a href="https://this-programmer.com/entry/" target="_blank" rel="noopener">https://this-programmer.com/entry/</a></p><p>위 문제를 해결하기 위해 인접행렬(Adjacency Matrix)를 사용했다. 인접행렬이란 자료형의 일종으로 어느 노드끼리 연결되었는지를 나타내는 이차원 행렬을 의미한다.</p><p>연결되어 있지 않은 노드는 0, 연결된 노드끼리는 1의 값을 저장한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">          [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">          [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">          [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><ul><li><p>BFS</p><p>탐색을 시작할 노드를 Queue에 저장하고 방문한 노드이므로 footPrint에도 똑같이 저장한다. Queue가 비어있을때 까지 반복문을 통해 노드를 탐색한다. 시작 노드와 같은 수준에 있는 노드를 탐색하고 같은 수준의 모든 노드를 탐색 후 하위 노드로 내려가 탐색을 이어간다. </p></li><li><p>DFS</p><p>탐색을 시작할 노드를 방문한 노드를 저장하는  footPrint에 저장하고 인접행렬을 통해 현재 노드와 연결된 노드를 탐색한다. 연결된 노드가 아직 방문하지 않은 노드라면 재귀호출을 통해 연결된 노드를 추가하고 연결된 노드를 시작 노드로하여 탐색을 이어간다.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">N, M, V = map(int, input().split())</span><br><span class="line">matrix = [[<span class="number">0</span>] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(M):</span><br><span class="line">    edge = list(map(int, input().split()))</span><br><span class="line">    matrix[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">    matrix[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">( currentNode, row, footPrints )</span>:</span></span><br><span class="line">    footPrints += [currentNode]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> search_node <span class="keyword">in</span> range(len(row[currentNode])):</span><br><span class="line">        <span class="keyword">if</span> row[currentNode][search_node] <span class="keyword">and</span> search_node <span class="keyword">not</span> <span class="keyword">in</span> footPrints:</span><br><span class="line">            footPrints = dfs(search_node, row, footPrints)</span><br><span class="line">    <span class="keyword">return</span> footPrints</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">( start )</span>:</span></span><br><span class="line">    queue = [start]</span><br><span class="line">    footPrints = [start]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        currentNode = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> search_node <span class="keyword">in</span> range(len(matrix[currentNode])):</span><br><span class="line">            <span class="keyword">if</span> matrix[currentNode][search_node] <span class="keyword">and</span> search_node <span class="keyword">not</span> <span class="keyword">in</span> footPrints:</span><br><span class="line">                footPrints += [search_node]</span><br><span class="line">                queue += [search_node]</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> footPrints</span><br><span class="line"></span><br><span class="line">print(*dfs(V, matrix, []))</span><br><span class="line">print(*bfs(V))</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/BFS_DFS/BFSDFS" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/BFS_DFS/BFSDFS</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="BFS/DFS Algorithm" scheme="https://bangkm.github.io/tags/BFS-DFS-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#5585) - Change (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/06/BaekJoon(5585)/"/>
    <id>https://bangkm.github.io/2019/10/06/BaekJoon(5585)/</id>
    <published>2019-10-06T11:50:56.000Z</published>
    <updated>2019-10-06T11:54:46.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 준다. 타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.</p><p>예를 들어 입력된 예1의 경우에는 아래 그림에서 처럼 4개를 출력해야 한다.</p><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/5585/1.png"><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>제출할 출력 파일은 1행으로만 되어 있다. 잔돈에 포함된 매수를 출력하시오.</p><h3 id="예제-입력"><a href="#예제-입력" class="headerlink" title="예제 입력"></a>예제 입력</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">380</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력"><a href="#예제-출력" class="headerlink" title="예제 출력"></a>예제 출력</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>잡화점에서 보유하고 있는 잔돈 500, 100, 50, 10, 5, 1엔을 리스트에 저장한 후 타로가 카운터에 제출한 1000엔에서 물건 값을 뺀 후 가장 적은 수의 잔돈을 계산한다.</p><p><strong>백준 알고리즘 - #11047</strong> 문제와 유사한 문제로 동일하게 divmod(a, b) 함수를 사용하여 잔돈 갯수의 최소값을 구한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = divmod(x, y) <span class="comment"># x를 y로 나눈 후, 몫은 a, 나머지는 b 변수에 저장된다</span></span><br></pre></td></tr></table></figure><p>몫은 필요한 동전의 개수로 result 변수에 더해주고, 나머지는 필요한 동전만큼 빼고 현재 남은 금액을 나타냄으로 현재 남은 잔돈의 금액에 저장하며 잔돈이 0원이 될때까지 반복 후 총 잔돈의 갯수를 출력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">price = int(input())</span><br><span class="line">changes = [<span class="number">500</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">change = <span class="number">1000</span> - price</span><br><span class="line"></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> changes:</span><br><span class="line">    <span class="keyword">if</span> change &lt; i:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a, b = divmod(change, i)</span><br><span class="line">        result += a</span><br><span class="line">        change = b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> change == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/change" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/change</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#11399) - Coin (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/05/BaekJoon(11047)/"/>
    <id>https://bangkm.github.io/2019/10/05/BaekJoon(11047)/</id>
    <published>2019-10-04T15:21:15.000Z</published>
    <updated>2019-10-04T15:25:10.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.</p><p>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)</p><p>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.</p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">4200</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">500</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">5000</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">4790</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">500</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">5000</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">50000</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>동전의 종류를 역순으로 현재 가지고 있는 금액과 비교한다. 동전의 종류가 현재 가지고 있는 금액보다 크면 continue, 작으면  divmod 함수를 사용하여 몫과 나머지를 구해준다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = divmod(x, y) <span class="comment"># x를 y로 나눈 후, 몫은 a, 나머지는 b 변수에 저장된다</span></span><br></pre></td></tr></table></figure><p>몫은 필요한 동전의 개수로 result 변수에 더해주고, 나머지는 필요한 동전만큼 빼고 현재 남은 금액을 나타냄으로 현재 가지고 있는 금액 변수인 haveCash에 저장하여 금액이 0원이 될때까지 반복 후 동전의 갯수를 출력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kindOfcoine = []</span><br><span class="line">nAndk = list(map(int, input().split()))</span><br><span class="line">haveCash = nAndk[<span class="number">1</span>]</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nAndk[<span class="number">0</span>]):</span><br><span class="line">    kindOfcoine.append(int(input()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(kindOfcoine):</span><br><span class="line">    <span class="keyword">if</span> haveCash &lt; i:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a, b = divmod(haveCash, i)</span><br><span class="line">        result += a</span><br><span class="line">        haveCash = b</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> haveCash == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/coin" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/coin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.&lt;/p&gt;
&lt;p&gt;동전을 적절히 사용해서 그 가치
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CodeUp(#2001) - MinumumPayment (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/04/MinumumPayment/"/>
    <id>https://bangkm.github.io/2019/10/04/MinumumPayment/</id>
    <published>2019-10-03T17:18:35.000Z</published>
    <updated>2019-10-03T17:25:12.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>파파 파스타 가게는 점심 추천 파스타와 생과일 쥬스 세트 메뉴가 인기가 좋다. 이 세트 메뉴를 주문하면 그 날의 3 종류의 파스타와 2 종류의 생과일 쥬스에서 하나씩 선택한다. <strong>파스타와 생과일 쥬스의 가격 합계에서 10%를 더한 금액이 대금된다.</strong> 어느 날의 파스타와 생과일 쥬스의 가격이 주어 졌을 때, 그 날 세트 메뉴의 대금의 최소값을 구하는 프로그램을 작성하라.</p><hr><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 5행으로 이루어지며, 한 줄에 하나씩 양의 정수가 적혀있다.</p><p>1행의 점수는 <strong>첫 번째 파스타</strong> 가격이다.</p><p>2행의 점수는 <strong>두 번째 파스타</strong> 가격이다.</p><p>3행의 점수는 <strong>세 번째 파스타</strong> 가격이다.</p><p>4행의 점수는 <strong>첫 번째 생과일 쥬스</strong> 가격이다.</p><p>5행의 점수는 <strong>두 번째 생과일 쥬스</strong> 가격이다.</p><p>(모든 파스타와 생과일 쥬스의 가격은 100원 이상 2000원 이하이다)</p><hr><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>그날 세트 메뉴의 <strong>최소 대금을 소수 첫째자리까지</strong> 출력하시오.</p><hr><h3 id="입력-예시"><a href="#입력-예시" class="headerlink" title="입력 예시"></a>입력 예시</h3><p>800</p><p>700</p><p>900</p><p>198</p><p>330</p><hr><h3 id="출력-예시"><a href="#출력-예시" class="headerlink" title="출력 예시"></a>출력 예시</h3><p>987.8</p><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>배열의 인덱스 0~2는 파스타의 가격, 3-4는 생과일 쥬스의 가격이다. 이중 for loop로 파스타에 해당되는 인덱스(0-2)와 생과일 쥬스에 해당되는 인덱스(3-4)의 가격을 더한 후 합이 제일 작은 금액을 구한다. 마지막으로 최소 금액의 10%를 더한 값을 출력한다</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">800</span>, <span class="number">700</span>, <span class="number">900</span>, <span class="number">198</span>, <span class="number">330</span>]</span><br><span class="line">totalPrice = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> pasta <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> drink <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">5</span>):</span><br><span class="line">        sumPrice = prices[pasta] + prices[drink]</span><br><span class="line">        <span class="keyword">if</span> pasta == <span class="number">0</span> <span class="keyword">and</span> drink == <span class="number">3</span>:</span><br><span class="line">            totalPrice = sumPrice</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sumPrice &lt; totalPrice:</span><br><span class="line">            totalPrice = sumPrice</span><br><span class="line"></span><br><span class="line">print(totalPrice + (totalPrice * <span class="number">0.1</span>))</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/code-up/MinimunPayment" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/code-up/MinimunPayment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;파파 파스타 가게는 점심 추천 파스타와 생과일 쥬스 세트 메뉴가 인기가 좋다. 이 세트 메뉴를 주문하면 그 날의 3 종류의 파
      
    
    </summary>
    
    
      <category term="Code-Up Algorithm" scheme="https://bangkm.github.io/categories/Code-Up-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BaekJoon(#11399) - ATM (Greedy Algorithm)</title>
    <link href="https://bangkm.github.io/2019/10/04/BaekJoon(11399)/"/>
    <id>https://bangkm.github.io/2019/10/04/BaekJoon(11399)/</id>
    <published>2019-10-03T16:34:58.000Z</published>
    <updated>2019-10-03T17:17:12.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.</p><p>사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.</p><p>줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.</p><p>줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.</p><h3 id="예제-입력"><a href="#예제-입력" class="headerlink" title="예제 입력"></a>예제 입력</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="예제-출력"><a href="#예제-출력" class="headerlink" title="예제 출력"></a>예제 출력</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>각 사람의 돈을 인출하는데 걸리는 시간이 가장 작은 순으로 줄을스면 인출하는데 걸리는 시간의 총합의 최솟값을 구할 수 있다. 즉, 오름 차순으로 정렬하여 각 사람당 인출하는데 걸리는 시간을 구하고 시간의 총합을 구하면 최솟값이 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">times = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">times.sort()</span><br><span class="line">sumList = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> time <span class="keyword">in</span> times:</span><br><span class="line">    sumList += time</span><br><span class="line">    result.append(sumList)</span><br><span class="line"></span><br><span class="line">print(sum(result))</span><br></pre></td></tr></table></figure><p>[ Source ] <a href="https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/atm" target="_blank" rel="noopener">https://github.com/bangkm/study-algorithm/tree/master/baekjoon/greedy_algorithm/atm</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져
      
    
    </summary>
    
    
      <category term="BaekJoon Algorithm" scheme="https://bangkm.github.io/categories/BaekJoon-Algorithm/"/>
    
    
      <category term="Greedy Algorithm" scheme="https://bangkm.github.io/tags/Greedy-Algorithm/"/>
    
  </entry>
  
</feed>
